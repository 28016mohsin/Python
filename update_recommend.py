# -*- coding: utf-8 -*-
"""recommend.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXLL8EyGETbqYvRxFQknSCa2MMfGPtyG
"""

from IPython.core.display import HTML
import random
import sys
import json
import numpy as np
import copy

data_file = "data/data.json"

numerical_features = ['year', 'rating', 'runtime', 'mpaa', 'votes']
category_features = ['genres', 'countries', 'languages', 'aspect ratio', 'director', 'cast', 'production companies', 'cinematographer', 'original music', 'producer', 'writer', 'keywords']
dictionary_features = ['demographic', 'parents guide']

def import_movies():
    title2movie = {}
    with open(data_file) as f:
        data = json.load(f)
    for movie in data:
        title2movie[movie['title']] = movie
    return title2movie

def postprocess_movies(title2movie):
    for _, movie in title2movie.items():
        if 'runtime' in movie:
            try:
                movie['runtime'] = int(movie['runtime'][0])
            except ValueError:
                del movie['runtime']
        mpaa_ratings = {'Rated G': 0, 'Rated PG': 1, 'Rated PG-13': 2, 'Rated R': 3, 'Rated NC-17': 4}
        if 'mpaa' in movie:
            movie['mpaa'] = mpaa_ratings.get(movie['mpaa'], None)

def create_vectors(title2movie):
    title2MVec = {}
    for title, movie in title2movie.items():
        vec = np.zeros(len(numerical_features) + len(category_features))
        for i, feat in enumerate(numerical_features):
            vec[i] = float(movie.get(feat, 0))
        for i, feat in enumerate(category_features, start=len(numerical_features)):
            vec[i] = 1.0 if feat in movie and movie[feat] else 0.0
        title2MVec[title] = vec
    return title2MVec

def normalize_vectors(title2MVec):
    all_vecs = np.array(list(title2MVec.values()))
    means = np.mean(all_vecs, axis=0)
    stds = np.std(all_vecs, axis=0)
    for title in title2MVec:
        title2MVec[title] = (title2MVec[title] - means) / stds

def manh_dist(mvec1, mvec2):
    return np.sum(np.abs(mvec1 - mvec2))

def get_recommendations(query_title, title2MVec, distance_function):
    query_vec = title2MVec[query_title]
    distances = [(title, distance_function(query_vec, vec)) for title, vec in title2MVec.items() if title != query_title]
    distances.sort(key=lambda x: x[1])
    return distances[:10]

def main():
    title2movie = import_movies()
    postprocess_movies(title2movie)
    title2MVec = create_vectors(title2movie)
    normalize_vectors(title2MVec)

    feat2weight = {
        'year': 1.0,
        'runtime': 1.0,
        'rating': 1.0,
        'mpaa': 0.0,
        'votes': 0.5
    }

    for title, vec in title2MVec.items():
        for i, feat in enumerate(numerical_features + category_features):
            vec[i] *= feat2weight.get(feat, 1.0)

    recommendations = get_recommendations("Fight Club", title2MVec, manh_dist)
    print("Top recommendations for 'Fight Club':", recommendations)

if __name__ == "__main__":
    main()